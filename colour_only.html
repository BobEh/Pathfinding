<!DOCTYPE html>
<html>
    <head>
        <title>Colour only</title>
        <style>
            body{
                margin: 0;
            }
            canvas{
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            var renderer = new THREE.WebGLRenderer();

            var runner;
            var clock = new THREE.Clock();


            //set the size of the renderer
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            //create geometry
            var geometry = new THREE.BoxGeometry(1,1,1);
            //var material = new THREE.MeshBasicMaterial({color: 0x777777});
            //var imageMap = new THREE.TextureLoader().load('images/walking_bear_2.jpg');
            //var material = new THREE.MeshBasicMaterial({map: imageMap});

            var runnerTexture = new THREE.ImageUtils.loadTexture('images/walking_bear_2.jpg');
            runner = new TextureAnimator(runnerTexture, 6, 1, 6, 100);
            var material = new THREE.MeshBasicMaterial({map: runnerTexture});

            var cube = new THREE.Mesh(geometry, material);

            //add cube to the scene
            scene.add(cube);

            //set camera position
            camera.position.z = 5;

            //create animate function
            var animate = function (){
                requestAnimationFrame(animate);

                //rotate cube
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;

                var delta = clock.getDelta();
                runner.update(1000 * delta);

                renderer.render(scene, camera);
            }

            //call animate
            animate();

            function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) 
            {	
                // note: texture passed by reference, will be updated by the update function.
                    
                this.tilesHorizontal = tilesHoriz;
                this.tilesVertical = tilesVert;
                // how many images does this spritesheet contain?
                //  usually equals tilesHoriz * tilesVert, but not necessarily,
                //  if there at blank tiles at the bottom of the spritesheet. 
                this.numberOfTiles = numTiles;
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
                texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

                // how long should each image be displayed?
                this.tileDisplayDuration = tileDispDuration;

                // how long has the current image been displayed?
                this.currentDisplayTime = 0;

                // which image is currently being displayed?
                this.currentTile = 0;
                    
                this.update = function( milliSec )
                {
                    this.currentDisplayTime += milliSec;
                    while (this.currentDisplayTime > this.tileDisplayDuration)
                    {
                        this.currentDisplayTime -= this.tileDisplayDuration;
                        this.currentTile++;
                        if (this.currentTile == this.numberOfTiles)
                            this.currentTile = 0;
                        var currentColumn = this.currentTile % this.tilesHorizontal;
                        texture.offset.x = currentColumn / this.tilesHorizontal;
                        var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
                        texture.offset.y = currentRow / this.tilesVertical;
                    }
                };
            }	

        </script>

    </body>
</html>